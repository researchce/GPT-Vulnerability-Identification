import os
import json
import time
from itertools import combinations
from tabulate import tabulate  # Ensure the tabulate library is installed
from mongoDBHandler import MongoDBHandler

"""
This script manages the upload and comparison of CVE (Common Vulnerabilities and Exposures) data to MongoDB collections.
It includes functionalities to:
- Load configuration settings.
- Upload JSON data to MongoDB collections.
- Clean MongoDB collections.
- Compare CVE data across different collections.

Classes:
- UploadDataExperimentManager: Manages the upload and comparison of CVE data.

Functions:
- load_config: Loads configuration from a JSON file.
- run_experiment: Runs the experiment to upload data and compare collections.
- show_results: Displays the results of the upload process in a formatted table.
- clean_collections: Cleans specified MongoDB collections.
- compare_collections: Compares CVE data between two collections.
- compare_all_collections: Compares CVE data across all specified collections.
- compare_vulnerable_modules: Compares the count of vulnerable modules between two collections.
- comparte_not_detected: Compares CVE-IDs with zero modules detected between two collections.
- get_cve_ids_with_zero_modules: Retrieves CVE-IDs with zero modules from a collection.

Usage:
- Set the CONFIG_PATH environment variable to point to the configuration file.
- Run the script to clean collections, upload data, and compare results.
"""

class UploadDataExperimentManager:
    def __init__(self, config_path):
        # Initialize with configuration and MongoDB handler
        self.config = self.load_config(config_path)
        self.mongo_handler = MongoDBHandler(self.config["connection_string"], self.config["database_name"])

    def load_config(self, config_path):
        # Load configuration from a JSON file
        with open(config_path, "r") as f:
            config = json.load(f)
        return config

    def run_experiment(self):
        # Run the experiment: upload data and compare collections
        start_time = time.time()
        upload_results = []
        for experiment_config in self.config["experiments"]:
            json_file_path = experiment_config["json_file_path"]
            collection_name = experiment_config["collection_name"]
            key = experiment_config["key"]

            # Upload JSON data to MongoDB
            print(f"Uploading JSON data from {json_file_path} to collection {collection_name} with key {key}")
            upload_start_time = time.time()
            uploaded_ids = self.mongo_handler.upload_json(json_file_path, collection_name, key)
            upload_end_time = time.time()
            upload_duration = upload_end_time - upload_start_time
            print(f"Uploaded {len(uploaded_ids)} documents in {upload_duration:.2f} seconds.")

            # Measure the number of records in the database
            record_count = self.mongo_handler.get_record_count(collection_name)
            print(f"Collection '{collection_name}' contains {record_count} documents.")

            upload_results.append({
                "Collection Name": collection_name,
                "Uploaded Documents": len(uploaded_ids),
                "Upload Duration (seconds)": round(upload_duration, 2),
                "Document Count": record_count
            })

        end_time = time.time()
        total_duration = end_time - start_time
        print(f"Experiment completed in {total_duration:.2f} seconds.")
        self.show_results(upload_results)

        # Compare all combinations of collections
        collection_names = [experiment["collection_name"] for experiment in self.config["experiments"]]
        self.compare_all_collections(collection_names)

    def show_results(self, upload_results):
        # Display the results of the upload process in a formatted table
        headers = ["Collection Name", "Uploaded Documents", "Upload Duration (s)", "Document Count"]
        table = [[r["Collection Name"], r["Uploaded Documents"], r["Upload Duration (seconds)"], r["Document Count"]] for r in upload_results]
        print(tabulate(table, headers=headers, tablefmt="grid"))
    
    def clean_collections(self):
        # Clean specified MongoDB collections
        for experiment_config in self.config["experiments"]:
            collection_name = experiment_config["collection_name"]
            print(f"Cleaning collection '{collection_name}'...")
            self.mongo_handler.delete_collection(collection_name)
            print(f"Collection '{collection_name}' cleaned successfully.")

    def compare_collections(self, collection1_name, collection2_name):
        # Compare CVE data between two collections
        collection1 = self.mongo_handler.db[collection1_name]
        collection2 = self.mongo_handler.db[collection2_name]

        # Find CVE_IDs in collection1 but not in collection2
        cve_ids_in_collection1 = set(doc["CVE_ID"] for doc in collection1.find({}, {"CVE_ID": 1}))
        cve_ids_in_collection2 = set(doc["CVE_ID"] for doc in collection2.find({}, {"CVE_ID": 1}))
        cve_ids_only_in_collection1 = cve_ids_in_collection1 - cve_ids_in_collection2

        # Find CVE_IDs in collection2 but not in collection1
        cve_ids_only_in_collection2 = cve_ids_in_collection2 - cve_ids_in_collection1

        return {
            f"CVE_IDs only in {collection1_name}": list(cve_ids_only_in_collection1),
            f"CVE_IDs only in {collection2_name}": list(cve_ids_only_in_collection2)
        }

    def compare_all_collections(self, collection_names):
        # Compare CVE data across all specified collections
        comparisons = {}
        modules_count_differences = {}
        modules_not_detected = {}
        for pair in combinations(collection_names, 2):
            collection1_name, collection2_name = pair
            comparisons[f"{collection1_name} vs {collection2_name}"] = self.compare_collections(collection1_name, collection2_name)
            modules_count_differences[f"{collection1_name} vs {collection2_name}"] = self.compare_vulnerable_modules(collection1_name, collection2_name)
            modules_not_detected[f"{collection1_name} vs {collection2_name}"] = self.comparte_not_detected(collection1_name, collection2_name)
        print("\nComparison Results:")
        for pair, result in comparisons.items():
            print(pair)
            print("  ", result)
        print("\Modules Count Difference Results:")
        for pair, result in modules_count_differences.items():
            print(pair)
            collection_1_len = len(result["Collection1"])
            collection_2_len = len(result["Collection2"])
            print(f"Modules difference in Collection1 {collection_1_len}")
            print(f"Modules difference in Collection2 {collection_2_len}")
        print("\Modules Not Detected Count Results:")
        for pair, result in modules_not_detected.items():
            print(pair)
            collection_1_len = len(result["Collection1"])
            collection_2_len = len(result["Collection2"])
            print(f"Count Modules not detected in Collection1 {collection_1_len}")
            print(f"Count Modules not detected in Collection2 {collection_2_len}")

    def compare_vulnerable_modules(self, collection_name_1, collection_name_2):
        # Compare the count of vulnerable modules between two collections
        # Get the module count for each CVE in the first collection
        module_counts_1 = self.mongo_handler.get_module_count_per_document(collection_name_1)
        module_count_map_1 = {doc["CVE-ID"]: doc["ModulesCount"] for doc in module_counts_1}

        # Get the module count for each CVE in the second collection
        module_counts_2 = self.mongo_handler.get_module_count_per_document(collection_name_2)
        module_count_map_2 = {doc["CVE-ID"]: doc["ModulesCount"] for doc in module_counts_2}

        # Compare the module counts and save the differences
        differences_1 = []
        differences_2 = []

        for cve_id, modules_count_1 in module_count_map_1.items():
            modules_count_2 = module_count_map_2.get(cve_id)
            if modules_count_2 is None or modules_count_1 != modules_count_2:
                differences_1.append({"CVE-ID": cve_id, "ModulesCount": modules_count_1})
                if modules_count_2 is not None:
                    differences_2.append({"CVE-ID": cve_id, "ModulesCount": modules_count_2})

        for cve_id, modules_count_2 in module_count_map_2.items():
            if cve_id not in module_count_map_1:
                differences_2.append({"CVE-ID": cve_id, "ModulesCount": modules_count_2})

        return {"Collection1": differences_1, "Collection2": differences_2}

    def comparte_not_detected(self, collection_name_1, collection_name_2):
        # Compare CVE-IDs with zero modules detected between two collections
        # Get CVE-IDs with zero modules for collection 1
        cve_ids_with_zero_modules_1 = self.get_cve_ids_with_zero_modules(collection_name_1)

        # Get CVE-IDs with zero modules for collection 2
        cve_ids_with_zero_modules_2 = self.get_cve_ids_with_zero_modules(collection_name_2)

        return {"Collection1": cve_ids_with_zero_modules_1, "Collection2": cve_ids_with_zero_modules_2}

    def get_cve_ids_with_zero_modules(self, collection_name):
        # Retrieve CVE-IDs with zero modules from a collection
        module_counts = self.mongo_handler.get_module_count_per_document(collection_name)
        cve_ids_with_zero_modules = [doc["CVE-ID"] for doc in module_counts if doc["ModulesCount"] == 0]
        return cve_ids_with_zero_modules

if __name__ == "__main__":
    # Set CONFIG_PATH environment variable
    config_path = os.getenv("CONFIG_PATH")
    experiment_manager = UploadDataExperimentManager(config_path)
    experiment_manager.clean_collections()
    experiment_manager.run_experiment()
