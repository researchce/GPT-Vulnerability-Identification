from openai import OpenAI
import json
import pandas as pd
import numpy as np
import time
from datetime import datetime
from joblib import Parallel, delayed

CANDIDATE = '** RESERVED ** This candidate has been reserved by an organization or individual that will use it when announcing a new security problem. When the candidate has been publicized, the details for this candidate will be provided.'

"""
This script processes and analyzes CVE data using OpenAI's GPT-3.5 model. It includes functions to:
- Validate the structure of JSON data for CVEs.
- Load CVE information from a CSV file.
- Generate prompts for OpenAI's API to get information on CVEs.
- Clean and save the results from the API.
- Run experiments in parallel to process multiple CVEs.

Functions:
- validate_json_structure: Checks if the JSON data has the required structure.
- open_cve_list: Loads CVE information from a CSV file.
- call_open_api: Calls OpenAI's API with a given prompt.
- load_prompt_text: Loads and formats the prompt text from a file.
- clean_result: Parses the API response and ensures it is in the correct format.
- save_result: Saves the JSON data to a file.
- analyze_cve: Analyzes a single CVE and retries if necessary.
- generate_examples: Generates example data for a range of CVEs.
- analyze_cves: Analyzes a range of CVEs and saves the execution time.
- runExperimentCreator: Runs the CVE analysis experiment in parallel.
- runExperimentExamples: Runs the example generation experiment in parallel.

Usage:
- Set the OPENAI_API_KEY environment variable.
- Call runExperimentExamples or runExperimentCreator to start the experiments.
"""

def validate_json_structure(json_data, cve_id):
    try:
        # Check if JSON contains 'CVE_ID' and 'vulnerable_versions' keys
        if 'CVE_ID' not in json_data:
            print(f"Error: 'CVE_ID' key not found in JSON {cve_id}", flush=True)
            return False
        if 'vulnerable_versions' not in json_data:
            print(f"Error: 'vulnerable_versions' key not found in JSON {cve_id}", flush=True)
            return False

        # Check if 'CVE_ID' is a string
        if not isinstance(json_data['CVE_ID'], str):
            print(f"Error: 'CVE_ID' is not a string in JSON for CVE {json_data['CVE_ID']}", flush=True)
            return False

        # Check if 'vulnerable_versions' is a list
        if not isinstance(json_data['vulnerable_versions'], list):
            print(f"Error: 'vulnerable_versions' is not a list in JSON for CVE {json_data['CVE_ID']}", flush=True)
            return False

        # Iterate through 'vulnerable_versions' list
        for i, item in enumerate(json_data['vulnerable_versions']):
            # Check if each item is a dictionary
            if not isinstance(item, dict):
                print(f"Error: Item {i + 1} in 'vulnerable_versions' is not a dictionary in JSON for CVE {json_data['CVE_ID']}", flush=True)
                return False
            # Check if each item contains 'module' and 'versions' keys
            if 'module' not in item:
                print(f"Error: 'module' key not found in item {i + 1} of 'vulnerable_versions' for CVE {json_data['CVE_ID']}", flush=True)
                return False
            if 'versions' not in item:
                print(f"Error: 'versions' key not found in item {i + 1} of 'vulnerable_versions' for CVE {json_data['CVE_ID']}", flush=True)
                return False
            # Check if 'module' and 'versions' are strings
            if not isinstance(item['module'], str):
                print(f"Error: 'module' is not a string in item {i + 1} of 'vulnerable_versions' for CVE {json_data['CVE_ID']}", flush=True)
                return False
            if not isinstance(item['versions'], str):
                print(f"Error: 'versions' is not a string in item {i + 1} of 'vulnerable_versions' for CVE {json_data['CVE_ID']}", flush=True)
                return False

        # If all checks passed, return True
        return True
    except json.JSONDecodeError:
        # If JSON decoding error occurs, return False
        print("Error: JSON decoding error", flush=True)
        return False

def open_cve_list(source):
    cve_information = pd.read_csv(source, index_col=False)
    return cve_information

def call_open_api(cve_prompt):
    client = OpenAI()
    fail = False
    generated_text = ""
    print(cve_prompt)
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo-0125",
            response_format={ "type": "json_object" },
            max_tokens=3000,
            messages=[
                {"role": "system", "content": "You are a helpful assistant designed to output JSON."},
                {"role": "user", "content": cve_prompt}
            ]
        )
        generated_text = response.choices[0].message.content
    except Exception as e:
        retry_time = 2
        print(f"Error {e}. Retrying in {retry_time} seconds...")
        time.sleep(retry_time)
        return call_open_api(cve_prompt)

    return generated_text, fail

def load_prompt_text(file, cve_id, cve_description):
    with open(file) as f:
        lines = " ".join([l.rstrip("\n") for l in f]) 
        lines = lines.replace("<cve-id>", cve_id)
        lines = lines.replace("<cve-description>", cve_description)
        return lines

def clean_result(string, cve_id):
    success = True
    json_string = ""
    try:
        json_string = json.loads(string)
        # success = validate_json_structure(json_string, cve_id)
    except:
        print("An exception occurred parsing cve")
        success = False
        json_string = {"CVE_ID": cve_id, "vulnerable_versions": []}
    
    return json_string, success

def save_result(json_string, cve_id): 
    with open(cve_id+'.json', 'w') as f:
        json.dump(json_string, f, indent=None)

def analyze_cve(cve_prompt, cve, database, database_name, attempt):
    if cve["DESCRIPTION"] == CANDIDATE:
        print("CANDIDATE "+ cve["CVE-ID"], flush=True)
        clean_response, success = {"CVE_ID": cve["CVE-ID"], "vulnerable_versions": []}
        
    elif cve["DESCRIPTION"] != CANDIDATE:
        response, fail = call_open_api(cve_prompt)
        clean_response, success = clean_result(response, cve["CVE-ID"])
        
    if success:
        database["cves"].append(clean_response)
        print("Analyzed "+ cve["CVE-ID"], flush=True)
        save_result(database, database_name)
    else:
        if attempt < 2:
            print("Retrying cve " + cve["CVE-ID"], flush=True)
            analyze_cve(cve_prompt, cve, database, database_name, attempt + 1)
        else:
            print("Abort cve " + cve["CVE-ID"], flush=True)      

def generate_examples(experiment, start, end, all):
    example_file = 'templates_gpt/vulnerableExamples.txt'
    database_name = 'examples-openai-'+str(experiment)
    source_file = '/Users/andresvargasrivera/repos/cve-automations/database/cves/2023_cves-purged-selected.csv'
    database = {"cves":[]}
    cves_info = open_cve_list(source_file)
    execution_times = []
    if all:
        end = cves_info.shape[0]
        print(end)
    for i, cve in cves_info.iterrows():
        if start <= i and i < end:
            print("start: ",start, "end: ",end, " index: ", i)
            cve_st = time.time()
            cve_prompt = load_prompt_text(example_file, cve["CVE-ID"], cve["DESCRIPTION"]) 
            analyze_cve(cve_prompt, cve, database, database_name, 0)
            cve_et = time.time()
            elapsed_time = cve_et - cve_st
            execution_times.append({"CVE_ID":cve["CVE-ID"], "Time":elapsed_time})
            save_result(execution_times, database_name + "-execution-time")

def analyze_cves(experiment, start, end, all=False):
    example_file = '/Users/andresvargasrivera/repos/cve-automations/open_ai_api/templates_gpt/extractVulnerableModulesExplicit.txt'
    database_name = 'results/content/database-openai-'+str(experiment)
    timebase_name = 'results/time/database-openai-'+str(experiment)
    source_file = '/Users/andresvargasrivera/repos/cve-automations/database/cves/2023_cves-purged.csv'
    database = {"cves":[]}
    cves_info = open_cve_list(source_file)
    if all:
        end = cves_info.shape[0]
        print(end)
    execution_times = []
    for i, cve in cves_info.iterrows():
        if start <= i and i < end:
            print("start: ",start, "end: ",end, " index: ", i)
            cve_st = time.time()
            cve_prompt = load_prompt_text(example_file, cve["CVE-ID"], cve["DESCRIPTION"]) 
            analyze_cve(cve_prompt, cve, database, database_name, 0)
            cve_et = time.time()
            elapsed_time = cve_et - cve_st
            execution_times.append({"CVE_ID":cve["CVE-ID"], "Time":elapsed_time})
            save_result(execution_times, timebase_name + "-execution-time")

def runExperimentCreator(jobs, bottom, top, all=False):
    # Measure the time taken by the function
    start_time = time.time() 
    Parallel(n_jobs=jobs)(delayed(analyze_cves)(index, (index * 1000), (index * 1000) + 1000, all) for index in range(bottom, top))
    # Record end time
    end_time = time.time()
    # Calculate elapsed time
    elapsed_time = end_time - start_time
    print(f"Time taken by your_function: {elapsed_time} seconds")

def runExperimentExamples(jobs, bottom, top, all=False):
    # Measure the time taken by the function
    start_time = time.time() 
    Parallel(n_jobs=jobs)(delayed(generate_examples)(index, (index * 1000), (index * 1000) + 1000, all) for index in range(bottom, top))
    # Record end time
    end_time = time.time()
    # Calculate elapsed time
    elapsed_time = end_time - start_time
    print(f"Time taken by your_function: {elapsed_time} seconds")

# export OPENAI_API_KEY=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
runExperimentExamples(4, 0, 4, False)
